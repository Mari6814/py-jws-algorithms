"""Tests for loading keys from files generated by openssl and ssh-keygen.

Tests cover:
- Sign/verify with openssl-generated PEM keys (RSA, ECDSA P-256/P-384/P-521, Ed25519)
- Sign/verify with ssh-keygen-generated keys (RSA, ECDSA 256/384/521, Ed25519)
- Sign/verify with encrypted private keys (both openssl and ssh-keygen)
- JWK export from file-loaded public and private keys
- JWK export with include_private from file-loaded private keys
- HMAC sign/verify with openssl-generated secrets from files
"""

from pathlib import Path

import pytest

from jws_algorithms.algorithms import AsymmetricAlgorithm, SymmetricAlgorithm

KEYS_DIR = Path(__file__).parent / "keys"
OPENSSL_DIR = KEYS_DIR / "openssl"
SSHKEYGEN_DIR = KEYS_DIR / "ssh-keygen"

PAYLOAD = b"Hello, World! This is a test payload for file-loaded keys."
ENC_PASSWORD = "testpassword"


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _has_bcrypt() -> bool:
    try:
        import bcrypt  # noqa: PLC0415, F401
    except ImportError:
        return False
    return True


requires_bcrypt = pytest.mark.skipif(not _has_bcrypt(), reason="bcrypt not installed")


# ===========================================================================
# OPENSSL KEY TESTS
# ===========================================================================


class TestOpenSSLSignVerify:
    """Sign and verify using openssl-generated PEM keys loaded from files."""

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
        ],
    )
    def test_rsa_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private.pem"
        public_key = OPENSSL_DIR / "rsa_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_pss_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private.pem"
        public_key = OPENSSL_DIR / "rsa_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_es256_sign_verify(self):
        algo = AsymmetricAlgorithm.ES256
        private_key = OPENSSL_DIR / "ec256_private.pem"
        public_key = OPENSSL_DIR / "ec256_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_es384_sign_verify(self):
        algo = AsymmetricAlgorithm.ES384
        private_key = OPENSSL_DIR / "ec384_private.pem"
        public_key = OPENSSL_DIR / "ec384_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_es512_sign_verify(self):
        algo = AsymmetricAlgorithm.ES512
        private_key = OPENSSL_DIR / "ec521_private.pem"
        public_key = OPENSSL_DIR / "ec521_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_eddsa_sign_verify(self):
        algo = AsymmetricAlgorithm.EdDSA
        private_key = OPENSSL_DIR / "ed25519_private.pem"
        public_key = OPENSSL_DIR / "ed25519_public.pem"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)


class TestOpenSSLEncryptedKeys:
    """Sign and verify using openssl-generated encrypted PEM keys."""

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
        ],
    )
    def test_rsa_encrypted_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private_enc.pem"
        public_key = OPENSSL_DIR / "rsa_public_enc.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_pss_encrypted_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private_enc.pem"
        public_key = OPENSSL_DIR / "rsa_public_enc.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    def test_es256_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES256
        private_key = OPENSSL_DIR / "ec256_private_enc.pem"
        public_key = OPENSSL_DIR / "ec256_public.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    def test_es384_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES384
        private_key = OPENSSL_DIR / "ec384_private_enc.pem"
        public_key = OPENSSL_DIR / "ec384_public.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    def test_es512_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES512
        private_key = OPENSSL_DIR / "ec521_private_enc.pem"
        public_key = OPENSSL_DIR / "ec521_public.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    def test_eddsa_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.EdDSA
        private_key = OPENSSL_DIR / "ed25519_private_enc.pem"
        public_key = OPENSSL_DIR / "ed25519_public.pem"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @pytest.mark.parametrize(
        ("algo", "private_key_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ec256_private_enc.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private_enc.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private_enc.pem"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc.pem"),
        ],
    )
    def test_wrong_password_raises(
        self, algo: AsymmetricAlgorithm, private_key_file: str
    ):
        private_key = OPENSSL_DIR / private_key_file
        with pytest.raises((ValueError, TypeError)):
            algo.sign(private_key, PAYLOAD, password="wrong_password")

    @pytest.mark.parametrize(
        ("algo", "private_key_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ec256_private_enc.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private_enc.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private_enc.pem"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc.pem"),
        ],
    )
    def test_no_password_raises(self, algo: AsymmetricAlgorithm, private_key_file: str):
        """Loading an encrypted key without a password should raise."""
        private_key = OPENSSL_DIR / private_key_file
        with pytest.raises((ValueError, TypeError)):
            algo.sign(private_key, PAYLOAD)


class TestSSHKeygenSignVerify:
    """Sign and verify using ssh-keygen-generated keys loaded from files."""

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = SSHKEYGEN_DIR / "rsa_private.pem"
        public_key = SSHKEYGEN_DIR / "rsa_private.pem.pub"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_ecdsa256_sign_verify(self):
        algo = AsymmetricAlgorithm.ES256
        private_key = SSHKEYGEN_DIR / "ecdsa256_private"
        public_key = SSHKEYGEN_DIR / "ecdsa256_private.pub"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_ecdsa384_sign_verify(self):
        algo = AsymmetricAlgorithm.ES384
        private_key = SSHKEYGEN_DIR / "ecdsa384_private"
        public_key = SSHKEYGEN_DIR / "ecdsa384_private.pub"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_ecdsa521_sign_verify(self):
        algo = AsymmetricAlgorithm.ES512
        private_key = SSHKEYGEN_DIR / "ecdsa521_private"
        public_key = SSHKEYGEN_DIR / "ecdsa521_private.pub"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)

    def test_ed25519_sign_verify(self):
        algo = AsymmetricAlgorithm.EdDSA
        private_key = SSHKEYGEN_DIR / "ed25519_private"
        public_key = SSHKEYGEN_DIR / "ed25519_private.pub"

        signature = algo.sign(private_key, PAYLOAD)
        assert algo.verify(public_key, PAYLOAD, signature)
        assert not algo.verify(public_key, b"wrong payload", signature)


class TestSSHKeygenEncryptedKeys:
    """Sign and verify using ssh-keygen-generated encrypted keys."""

    @requires_bcrypt
    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_encrypted_sign_verify(self, algo: AsymmetricAlgorithm):
        private_key = SSHKEYGEN_DIR / "rsa_private_enc.pem"
        public_key = SSHKEYGEN_DIR / "rsa_private_enc.pem.pub"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @requires_bcrypt
    def test_ecdsa256_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES256
        private_key = SSHKEYGEN_DIR / "ecdsa256_private_enc"
        public_key = SSHKEYGEN_DIR / "ecdsa256_private_enc.pub"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @requires_bcrypt
    def test_ecdsa384_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES384
        private_key = SSHKEYGEN_DIR / "ecdsa384_private_enc"
        public_key = SSHKEYGEN_DIR / "ecdsa384_private_enc.pub"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @requires_bcrypt
    def test_ecdsa521_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.ES512
        private_key = SSHKEYGEN_DIR / "ecdsa521_private_enc"
        public_key = SSHKEYGEN_DIR / "ecdsa521_private_enc.pub"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @requires_bcrypt
    def test_ed25519_encrypted_sign_verify(self):
        algo = AsymmetricAlgorithm.EdDSA
        private_key = SSHKEYGEN_DIR / "ed25519_private_enc"
        public_key = SSHKEYGEN_DIR / "ed25519_private_enc.pub"

        signature = algo.sign(private_key, PAYLOAD, password=ENC_PASSWORD)
        assert algo.verify(public_key, PAYLOAD, signature)

    @requires_bcrypt
    @pytest.mark.parametrize(
        ("algo", "private_key_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ecdsa256_private_enc"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private_enc"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private_enc"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc"),
        ],
    )
    def test_wrong_password_raises(
        self, algo: AsymmetricAlgorithm, private_key_file: str
    ):
        private_key = SSHKEYGEN_DIR / private_key_file
        with pytest.raises(ValueError):
            algo.sign(private_key, PAYLOAD, password="wrong_password")

    @requires_bcrypt
    @pytest.mark.parametrize(
        ("algo", "private_key_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ecdsa256_private_enc"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private_enc"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private_enc"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc"),
        ],
    )
    def test_no_password_raises(self, algo: AsymmetricAlgorithm, private_key_file: str):
        """Loading an encrypted ssh key without a password should raise."""
        private_key = SSHKEYGEN_DIR / private_key_file
        with pytest.raises(TypeError):
            algo.sign(private_key, PAYLOAD)


class TestOpenSSLJWK:
    """JWK export from openssl-generated keys loaded from files."""

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_public_jwk(self, algo: AsymmetricAlgorithm):
        public_key = OPENSSL_DIR / "rsa_public.pem"
        jwk = algo.to_jwk(public_key)

        assert jwk["kty"] == "RSA"
        assert jwk["alg"] == algo.name
        assert jwk["use"] == "sig"
        assert "n" in jwk
        assert "e" in jwk
        # No private fields
        assert "d" not in jwk

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
        ],
    )
    def test_rsa_private_key_yields_public_jwk(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private.pem"
        public_key = OPENSSL_DIR / "rsa_public.pem"

        jwk_from_private = algo.to_jwk(private_key)
        jwk_from_public = algo.to_jwk(public_key)

        assert jwk_from_private == jwk_from_public
        assert "d" not in jwk_from_private

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_include_private_jwk(self, algo: AsymmetricAlgorithm):
        private_key = OPENSSL_DIR / "rsa_private.pem"
        jwk = algo.to_jwk(private_key, include_private=True)

        assert jwk["kty"] == "RSA"
        assert jwk["alg"] == algo.name
        assert "n" in jwk
        assert "e" in jwk
        assert "d" in jwk
        assert "p" in jwk
        assert "q" in jwk
        assert "dp" in jwk
        assert "dq" in jwk
        assert "qi" in jwk

    @pytest.mark.parametrize(
        ("algo", "key_file", "expected_crv"),
        [
            (AsymmetricAlgorithm.ES256, "ec256_public.pem", "P-256"),
            (AsymmetricAlgorithm.ES384, "ec384_public.pem", "P-384"),
            (AsymmetricAlgorithm.ES512, "ec521_public.pem", "P-521"),
        ],
    )
    def test_ec_public_jwk(
        self, algo: AsymmetricAlgorithm, key_file: str, expected_crv: str
    ):
        public_key = OPENSSL_DIR / key_file
        jwk = algo.to_jwk(public_key)

        assert jwk["kty"] == "EC"
        assert jwk["crv"] == expected_crv
        assert jwk["alg"] == algo.name
        assert jwk["use"] == "sig"
        assert "x" in jwk
        assert "y" in jwk
        assert "d" not in jwk

    @pytest.mark.parametrize(
        ("algo", "private_file", "public_file"),
        [
            (AsymmetricAlgorithm.ES256, "ec256_private.pem", "ec256_public.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private.pem", "ec384_public.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private.pem", "ec521_public.pem"),
        ],
    )
    def test_ec_private_key_yields_public_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str, public_file: str
    ):
        jwk_from_private = algo.to_jwk(OPENSSL_DIR / private_file)
        jwk_from_public = algo.to_jwk(OPENSSL_DIR / public_file)

        assert jwk_from_private == jwk_from_public
        assert "d" not in jwk_from_private

    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.ES256, "ec256_private.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private.pem"),
        ],
    )
    def test_ec_include_private_jwk(self, algo: AsymmetricAlgorithm, private_file: str):
        jwk = algo.to_jwk(OPENSSL_DIR / private_file, include_private=True)

        assert jwk["kty"] == "EC"
        assert "x" in jwk
        assert "y" in jwk
        assert "d" in jwk

    def test_eddsa_public_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        public_key = OPENSSL_DIR / "ed25519_public.pem"
        jwk = algo.to_jwk(public_key)

        assert jwk["kty"] == "OKP"
        assert jwk["crv"] == "Ed25519"
        assert jwk["alg"] == "EdDSA"
        assert jwk["use"] == "sig"
        assert "x" in jwk
        assert "d" not in jwk

    def test_eddsa_private_key_yields_public_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        jwk_from_private = algo.to_jwk(OPENSSL_DIR / "ed25519_private.pem")
        jwk_from_public = algo.to_jwk(OPENSSL_DIR / "ed25519_public.pem")

        assert jwk_from_private == jwk_from_public
        assert "d" not in jwk_from_private

    def test_eddsa_include_private_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        jwk = algo.to_jwk(OPENSSL_DIR / "ed25519_private.pem", include_private=True)

        assert jwk["kty"] == "OKP"
        assert jwk["crv"] == "Ed25519"
        assert "x" in jwk
        assert "d" in jwk

    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ec256_private_enc.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private_enc.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private_enc.pem"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc.pem"),
        ],
    )
    def test_encrypted_private_key_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str
    ):
        """JWK export from encrypted private key should produce a public JWK."""
        jwk = algo.to_jwk(OPENSSL_DIR / private_file, password=ENC_PASSWORD)
        assert "d" not in jwk
        assert jwk["alg"] == algo.name

    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ec256_private_enc.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_private_enc.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_private_enc.pem"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc.pem"),
        ],
    )
    def test_encrypted_private_key_include_private_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str
    ):
        """JWK export from encrypted private key with include_private=True should include d."""
        jwk = algo.to_jwk(
            OPENSSL_DIR / private_file, password=ENC_PASSWORD, include_private=True
        )
        assert "d" in jwk
        assert jwk["alg"] == algo.name

    @pytest.mark.parametrize(
        ("algo", "public_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_public.pem"),
            (AsymmetricAlgorithm.ES256, "ec256_public.pem"),
            (AsymmetricAlgorithm.ES384, "ec384_public.pem"),
            (AsymmetricAlgorithm.ES512, "ec521_public.pem"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_public.pem"),
        ],
    )
    def test_jwk_no_padding_chars(self, algo: AsymmetricAlgorithm, public_file: str):
        jwk = algo.to_jwk(OPENSSL_DIR / public_file)
        for value in jwk.values():
            if isinstance(value, str) and value not in (
                jwk["kty"],
                jwk["alg"],
                jwk["use"],
                jwk.get("crv", ""),
            ):
                assert "=" not in value
                assert "+" not in value
                assert "/" not in value


class TestSSHKeygenJWK:
    """JWK export from ssh-keygen-generated keys loaded from files."""

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
            AsymmetricAlgorithm.PS256,
            AsymmetricAlgorithm.PS384,
            AsymmetricAlgorithm.PS512,
        ],
    )
    def test_rsa_public_jwk(self, algo: AsymmetricAlgorithm):
        public_key = SSHKEYGEN_DIR / "rsa_private.pem.pub"
        jwk = algo.to_jwk(public_key)

        assert jwk["kty"] == "RSA"
        assert jwk["alg"] == algo.name
        assert jwk["use"] == "sig"
        assert "n" in jwk
        assert "e" in jwk
        assert "d" not in jwk

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
        ],
    )
    def test_rsa_private_key_yields_public_jwk(self, algo: AsymmetricAlgorithm):
        jwk_private = algo.to_jwk(SSHKEYGEN_DIR / "rsa_private.pem")
        jwk_public = algo.to_jwk(SSHKEYGEN_DIR / "rsa_private.pem.pub")

        assert jwk_private == jwk_public
        assert "d" not in jwk_private

    @pytest.mark.parametrize(
        "algo",
        [
            AsymmetricAlgorithm.RS256,
            AsymmetricAlgorithm.RS384,
            AsymmetricAlgorithm.RS512,
        ],
    )
    def test_rsa_include_private_jwk(self, algo: AsymmetricAlgorithm):
        jwk = algo.to_jwk(SSHKEYGEN_DIR / "rsa_private.pem", include_private=True)

        assert jwk["kty"] == "RSA"
        assert "d" in jwk
        assert "p" in jwk
        assert "q" in jwk

    @pytest.mark.parametrize(
        ("algo", "pub_file", "expected_crv"),
        [
            (AsymmetricAlgorithm.ES256, "ecdsa256_private.pub", "P-256"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private.pub", "P-384"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private.pub", "P-521"),
        ],
    )
    def test_ecdsa_public_jwk(
        self, algo: AsymmetricAlgorithm, pub_file: str, expected_crv: str
    ):
        jwk = algo.to_jwk(SSHKEYGEN_DIR / pub_file)

        assert jwk["kty"] == "EC"
        assert jwk["crv"] == expected_crv
        assert jwk["alg"] == algo.name
        assert "x" in jwk
        assert "y" in jwk
        assert "d" not in jwk

    @pytest.mark.parametrize(
        ("algo", "private_file", "pub_file"),
        [
            (AsymmetricAlgorithm.ES256, "ecdsa256_private", "ecdsa256_private.pub"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private", "ecdsa384_private.pub"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private", "ecdsa521_private.pub"),
        ],
    )
    def test_ecdsa_private_key_yields_public_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str, pub_file: str
    ):
        jwk_private = algo.to_jwk(SSHKEYGEN_DIR / private_file)
        jwk_public = algo.to_jwk(SSHKEYGEN_DIR / pub_file)

        assert jwk_private == jwk_public
        assert "d" not in jwk_private

    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.ES256, "ecdsa256_private"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private"),
        ],
    )
    def test_ecdsa_include_private_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str
    ):
        jwk = algo.to_jwk(SSHKEYGEN_DIR / private_file, include_private=True)

        assert jwk["kty"] == "EC"
        assert "x" in jwk
        assert "y" in jwk
        assert "d" in jwk

    def test_eddsa_public_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        jwk = algo.to_jwk(SSHKEYGEN_DIR / "ed25519_private.pub")

        assert jwk["kty"] == "OKP"
        assert jwk["crv"] == "Ed25519"
        assert jwk["alg"] == "EdDSA"
        assert "x" in jwk
        assert "d" not in jwk

    def test_eddsa_private_key_yields_public_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        jwk_private = algo.to_jwk(SSHKEYGEN_DIR / "ed25519_private")
        jwk_public = algo.to_jwk(SSHKEYGEN_DIR / "ed25519_private.pub")

        assert jwk_private == jwk_public
        assert "d" not in jwk_private

    def test_eddsa_include_private_jwk(self):
        algo = AsymmetricAlgorithm.EdDSA
        jwk = algo.to_jwk(SSHKEYGEN_DIR / "ed25519_private", include_private=True)

        assert jwk["kty"] == "OKP"
        assert jwk["crv"] == "Ed25519"
        assert "x" in jwk
        assert "d" in jwk

    @requires_bcrypt
    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ecdsa256_private_enc"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private_enc"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private_enc"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc"),
        ],
    )
    def test_encrypted_private_key_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str
    ):
        jwk = algo.to_jwk(SSHKEYGEN_DIR / private_file, password=ENC_PASSWORD)
        assert "d" not in jwk
        assert jwk["alg"] == algo.name

    @requires_bcrypt
    @pytest.mark.parametrize(
        ("algo", "private_file"),
        [
            (AsymmetricAlgorithm.RS256, "rsa_private_enc.pem"),
            (AsymmetricAlgorithm.ES256, "ecdsa256_private_enc"),
            (AsymmetricAlgorithm.ES384, "ecdsa384_private_enc"),
            (AsymmetricAlgorithm.ES512, "ecdsa521_private_enc"),
            (AsymmetricAlgorithm.EdDSA, "ed25519_private_enc"),
        ],
    )
    def test_encrypted_include_private_jwk(
        self, algo: AsymmetricAlgorithm, private_file: str
    ):
        jwk = algo.to_jwk(
            SSHKEYGEN_DIR / private_file, password=ENC_PASSWORD, include_private=True
        )
        assert "d" in jwk
        assert jwk["alg"] == algo.name


class TestHMACFromFile:
    """Sign and verify using HMAC secrets loaded from openssl-generated random bytes files."""

    @pytest.mark.parametrize(
        ("algo", "key_file"),
        [
            (SymmetricAlgorithm.HS256, "hmac256.key"),
            (SymmetricAlgorithm.HS384, "hmac384.key"),
            (SymmetricAlgorithm.HS512, "hmac512.key"),
        ],
    )
    def test_hmac_sign_verify_from_file(self, algo: SymmetricAlgorithm, key_file: str):
        secret_path = OPENSSL_DIR / key_file
        signature = algo.sign(secret_path, PAYLOAD)
        assert algo.verify(secret_path, PAYLOAD, signature)
        assert not algo.verify(secret_path, b"wrong payload", signature)

    @pytest.mark.parametrize(
        ("algo", "key_file"),
        [
            (SymmetricAlgorithm.HS256, "hmac256.key"),
            (SymmetricAlgorithm.HS384, "hmac384.key"),
            (SymmetricAlgorithm.HS512, "hmac512.key"),
        ],
    )
    def test_hmac_file_vs_bytes_consistency(
        self, algo: SymmetricAlgorithm, key_file: str
    ):
        """Signing from file and from bytes loaded from the same file should match."""
        secret_path = OPENSSL_DIR / key_file
        secret_bytes = secret_path.read_bytes()

        sig_from_file = algo.sign(secret_path, PAYLOAD)
        sig_from_bytes = algo.sign(secret_bytes, PAYLOAD)

        assert sig_from_file == sig_from_bytes
